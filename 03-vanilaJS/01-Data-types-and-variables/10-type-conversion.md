# Перетворення типів у JavaScript

## Загальна інформація

- **Опис**: Перетворення типів (type conversion або type coercion) — це процес зміни типу даних значення в JavaScript (наприклад, із числа в рядок або з рядка в булеве значення).
- **Типи перетворень**:
  - **Явне (Explicit)**: Програміст явно вказує, як перетворити значення (наприклад, за допомогою `String()`, `Number()`, `Boolean()`).
  - **Неявне (Implicit)**: JavaScript автоматично виконує перетворення під час операцій (наприклад, при використанні `+` або `==`).
- **Контекст**: Перетворення типів часто відбувається в арифметичних операціях, порівняннях, логічних виразах і при роботі з примітивами.
- **Falsy і Truthy значення**:
  - **Falsy**: Значення, які приводяться до `false` у логічному контексті: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`.
  - **Truthy**: Усі значення, які не є falsy, приводяться до `true` (наприклад, `"string"`, `1`, `{}`, `[]`).
- **Особливості**: JavaScript — динамічно типізована мова, тому неявне перетворення типів є частим джерелом помилок, якщо не враховувати правила.

## Основні поняття

### Явне перетворення

- **До рядка (`String`)**: Використовуй `String()` або метод `.toString()` (для об’єктів і чисел).
- **До числа (`Number`)**: Використовуй `Number()`, `parseInt()`, `parseFloat()` або унарний плюс (`+`).
- **До булевого значення (`Boolean`)**: Використовуй `Boolean()` або подвійне заперечення (`!!`).
- **До примітиву**: Використовуй методи `valueOf()` або `toString()` для об’єктів, щоб отримати їхнє примітивне значення.

### Неявне перетворення

- Відбувається автоматично в операціях, таких як:
  - Арифметичні: `+`, `-`, `*`, `/`, `%` (за винятком `+` для конкатенації рядків).
  - Порівняння: `==` (нестрога рівність), `<`, `>`, `<=`, `>=`.
  - Логічні: Умови (`if`, `while`), оператори `&&`, `||`, `!`.
- Правила залежать від операторів і типів операндів.

### Falsy і Truthy у логічному контексті

- Умови (`if`, `while`) і логічні оператори приводять значення до булевого типу через внутрішній механізм `ToBoolean`.
- Наприклад, `0`, `""`, `null`, `undefined`, `NaN` стають `false`, а `"text"`, `1`, `{}` — `true`.

## Приклади коду

### Явне перетворення

```js
// До рядка
console.log(String(42)); // "42"
console.log((123.45).toString()); // "123.45"
console.log(String(true)); // "true"

// До числа
console.log(Number("42")); // 42
console.log(parseInt("42px")); // 42
console.log(parseFloat("3.14")); // 3.14
console.log(+"42"); // 42 (унарний плюс)

// До булевого значення
console.log(Boolean(1)); // true
console.log(Boolean("")); // false
console.log(!!"hello"); // true (подвійне заперечення)
```

### Неявне перетворення

```js
// Конкатенація рядків
console.log(42 + ""); // "42"
console.log("5" + 5); // "55"

// Арифметика (крім +)
console.log("5" - 2); // 3
console.log("10" * 2); // 20
console.log("8" / 2); // 4

// Порівняння
console.log("42" == 42); // true (нестроге порівняння)
console.log("42" === 42); // false (строге порівняння)
console.log(null == undefined); // true
console.log(null === undefined); // false

// Логічний контекст
if ("hello") {
  console.log("Truthy"); // Виведе
}
if (0) {
  console.log("Falsy"); // Не виведе
}
```

### Перетворення об’єктів до примітивів

```js
let obj = { valueOf: () => 42, toString: () => "object" };
console.log(+obj); // 42 (використовує valueOf)
console.log(String(obj)); // "object" (використовує toString)

let arr = [1, 2, 3];
console.log(arr + ""); // "1,2,3" (toString для масиву)
```

### Типові помилки

```js
console.log("5" + 5); // "55" (конкатенація, а не додавання)
console.log("abc" * 2); // NaN (некоректна операція)
console.log(+"hello"); // NaN (не можна перетворити в число)
console.log(null + undefined); // NaN (арифметика з undefined)
```

## Особливості для співбесід — Питання та відповіді

### У чому різниця між явним і неявним перетворенням типів?

- **Явне**: Програміст явно викликає функції, як `Number()`, `String()`, `Boolean()`. Контрольоване і передбачуване.
- **Неявне**: Відбувається автоматично в операціях (`+`, `==`, `if`). Може призводити до помилок через складні правила.
  ```js
  console.log(Number("42")); // 42 (явне)
  console.log("42" * 1); // 42 (неявне)
  ```

### Чому `"5" + 5` дає `"55"`, а `"5" - 2` дає `3`?

- Оператор `+` виконує конкатенацію, якщо один із операндів — рядок.
- Інші арифметичні оператори (`-`, `*`, `/`) намагаються перетворити операнди в числа.
  ```js
  console.log("5" + 5); // "55"
  console.log("5" - 2); // 3
  ```

### Чим відрізняються `==` і `===` у контексті перетворення типів?

- `==` виконує нестроге порівняння з приведенням типів (наприклад, `"42" == 42` → `true`).
- `===` порівнює значення і типи без приведення (`"42" === 42` → `false`).
  ```js
  console.log(null == undefined); // true
  console.log(null === undefined); // false
  ```

### Які значення є falsy?

- Falsy значення: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`.
- **Питання**: Чи є порожній масив (`[]`) або об’єкт (`{}`) falsy?
  - **Відповідь**: Ні, вони є truthy.
  ```js
  console.log(!![]); // true
  console.log(!!{}); // true
  ```

### Як працює перетворення об’єктів до примітивів?

- JavaScript використовує методи `valueOf()` і `toString()` для перетворення об’єктів у примітиви:
  - Для числового контексту: спочатку викликається `valueOf`, потім `toString` (якщо `valueOf` не повертає примітив).
  - Для рядкового контексту: спочатку `toString`, потім `valueOf`.
  ```js
  let obj = { valueOf: () => 42, toString: () => "obj" };
  console.log(+obj); // 42
  console.log(String(obj)); // "obj"
  ```

### Чому `parseInt` і `parseFloat` кращі за `Number` у деяких випадках?

- `parseInt` і `parseFloat` можуть обробляти рядки з нечисловими символами, витягуючи числову частину.
- `Number` повертає `NaN`, якщо рядок містить нечислові символи.
  ```js
  console.log(parseInt("42px")); // 42
  console.log(Number("42px")); // NaN
  ```

### Як уникнути помилок із неявним перетворенням?

- Використовуй `===` замість `==` для точного порівняння.
- Явно приводь типи перед операціями, щоб уникнути неочікуваних результатів.
  ```js
  let str = "42";
  console.log(Number(str) + 5); // 47 (явне перетворення)
  ```

## Поради

- **Завжди використовуй `===` для порівняння**: Нестрога рівність (`==`) може призвести до помилок через неявне приведення типів.
- **Явно приводь типи**: Використовуй `Number()`, `String()`, `Boolean()` для передбачуваності, особливо в критичних обчисленнях.
- **Перевіряй типи перед операціями**: Використовуй `typeof` або `Number.isNaN` для уникнення помилок із `NaN` чи `undefined`.
- **Будь обережним із `+`**: Якщо один із операндів — рядок, відбудеться конкатенація, а не додавання.
- **Використовуй `parseInt` із основою**: Завжди вказуй `radix` (наприклад, `parseInt("08", 10)`), щоб уникнути проблем у старих браузерах.
- **Перевіряй falsy значення в умовах**: Явно перевіряй `value === undefined` чи `value === null`, якщо це важливо, замість покладатися на falsy.
- **Уникай змішування типів**: Наприклад, перед арифметичними операціями переконайся, що обидва операнди — числа.

## Приклад повного використання

```js
"use strict";

// Явне перетворення
let numStr = "42";
console.log(Number(numStr)); // 42
console.log(parseFloat("3.14px")); // 3.14
console.log(Boolean("hello")); // true

// Неявне перетворення
console.log("5" + 5); // "55" (конкатенація)
console.log("5" - 2); // 3 (арифметика)
console.log("42" == 42); // true
console.log(!!0); // false (falsy)

// Об’єкти
let obj = { valueOf: () => 10, toString: () => "ten" };
console.log(+obj); // 10
console.log(String(obj)); // "ten"

// Умови
let value = "";
if (!value) {
  console.log("Value is falsy"); // Виведе
}
```
