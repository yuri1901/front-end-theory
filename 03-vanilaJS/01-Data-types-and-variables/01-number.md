# Тип Number у JavaScript

## Основні поняття

- **Опис**: Тип `Number` представляє числа (цілі та з плаваючою комою) у 64-бітному форматі IEEE 754.
- **Діапазон безпечних цілих чисел**: Від `Number.MIN_SAFE_INTEGER` (-9,007,199,254,740,991, або -2⁵³ + 1) до `Number.MAX_SAFE_INTEGER` (9,007,199,254,740,991, або 2⁵³ - 1).
- **Спеціальні значення**:
  - `Infinity` і `-Infinity`: Виникають при діленні на нуль або перевищенні числового діапазону.
  - `NaN` (Not-a-Number): Результат некоректних математичних операцій (наприклад, `0 / 0`).
- **Помилки з плаваючою комою**: Через обмежену точність у двійковій системі числа з плаваючою комою можуть давати неточні результати (наприклад, `0.1 + 0.2 !== 0.3`).
- **Числовий сепаратор**: Символ `_` використовується для покращення читабельності великих чисел (наприклад, `1_000_000`). Не впливає на значення.
- **Методи та функції**:
  - **Статичні методи**:
    - `Number.isNaN(value)`: Перевіряє, чи є значення `NaN` (без приведення типів).
    - `Number.isFinite(value)`: Перевіряє, чи є значення скінченним числом.
    - `Number.isInteger(value)`: Перевіряє, чи є значення цілим числом.
  - **Методи екземплярів**:
    - `toFixed(digits)`: Форматує число з фіксованою кількістю знаків після коми.
    - `toPrecision(precision)`: Форматує число з вказаною загальною кількістю значущих цифр.
    - `toExponential(digits)`: Повертає число в експоненціальній нотації.
  - **Глобальні функції**:
    - `parseInt(string, radix)`: Перетворює рядок на ціле число з урахуванням основи системи числення.
    - `parseFloat(string)`: Перетворює рядок на число з плаваючою комою.
    - `isFinite(value)`: Перевіряє, чи є значення скінченним числом (з приведенням типів).
    - `isNaN(value)`: Перевіряє, чи є значення `NaN` (з приведенням типів).

## Приклади коду

### Базові операції з Number

```js
let num = 42; // Ціле число
let float = 3.14; // Число з плаваючою комою
let infinity = 1 / 0; // Infinity
let nan = 0 / 0; // NaN

console.log(num); // 42
console.log(float); // 3.14
console.log(infinity); // Infinity
console.log(nan); // NaN
```

### Помилки з плаваючою комою

```js
let sum = 0.1 + 0.2;
console.log(sum); // 0.30000000000000004
// Рішення: множення/ділення для роботи з цілими числами
let fixedSum = (0.1 * 10 + 0.2 * 10) / 10;
console.log(fixedSum); // 0.3
```

### Числовий сепаратор

```js
let million = 1_000_000;
let billion = 1_000_000_000;
console.log(million); // 1000000
console.log(billion); // 1000000000
```

### Методи Number

```js
let num = 123.456;
console.log(num.toFixed(2)); // "123.46"
console.log(num.toPrecision(4)); // "123.5"
console.log(num.toExponential(2)); // "1.23e+2"

console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN("NaN")); // false
console.log(Number.isFinite(42)); // true
console.log(Number.isFinite(Infinity)); // false
console.log(Number.isInteger(42)); // true
console.log(Number.isInteger(3.14)); // false
```

### Глобальні функції

```js
console.log(parseInt("42px")); // 42
console.log(parseInt("1010", 2)); // 10 (двійкова система)
console.log(parseFloat("3.14 is pi")); // 3.14
console.log(parseInt("hello")); // NaN
console.log(isNaN("string")); // true
console.log(isFinite("42")); // true
```

### Межі безпечних чисел

```js
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991
console.log(Number.MAX_SAFE_INTEGER + 2); // 9007199254740992 (може бути неточним)
```

## Особливості для співбесід — Питання та відповіді

### Чому `0.1 + 0.2 !== 0.3` у JavaScript?

- Числа з плаваючою комою використовують формат IEEE 754, який має обмежену точність. Дробові числа, як `0.1` і `0.2`, не можуть бути точно представлені в двійковій системі, що призводить до помилок округлення.
- **Рішення**: Використовуй множення/ділення для роботи з цілими числами або бібліотеки (наприклад, `decimal.js`).
  ```js
  console.log(0.1 + 0.2); // 0.30000000000000004
  ```

### У чому різниця між `isNaN()` і `Number.isNaN()`?

- `isNaN(value)` приводить аргумент до числа, тому `isNaN("string")` повертає `true`, оскільки `"string"` приводиться до `NaN`.
- `Number.isNaN(value)` перевіряє, чи значення є саме `NaN`, без приведення типів.
  ```js
  console.log(isNaN("string")); // true
  console.log(Number.isNaN("string")); // false
  ```

### Чим відрізняються `isFinite` і `Number.isFinite`?

- `isFinite(value)` приводить аргумент до числа, тому `isFinite("42")` повертає `true`.
- `Number.isFinite(value)` перевіряє, чи є значення числом і чи воно скінченне, тому `Number.isFinite("42")` повертає `false`.
  ```js
  console.log(isFinite("42")); // true
  console.log(Number.isFinite("42")); // false
  ```

### Що таке `Number.MAX_SAFE_INTEGER` і `Number.MIN_SAFE_INTEGER`?

- Це константи, які визначають діапазон цілих чисел, які можна безпечно використовувати без втрати точності: від `-2⁵³ + 1` до `2⁵³ - 1`.
- **Питання**: Що станеться, якщо перевищити цей діапазон?
  - **Відповідь**: Обчислення можуть стати неточними. Наприклад, `Number.MAX_SAFE_INTEGER + 2` може дати неправильний результат.

### Чому `NaN` не дорівнює самому собі?

- `NaN` — спеціальне значення, яке представляє "не число". За стандартом IEEE 754, `NaN !== NaN`.
  ```js
  console.log(NaN === NaN); // false
  ```

### Як працює `toFixed` і коли його використовувати?

- `toFixed(digits)` повертає рядок, представляючи число з фіксованою кількістю знаків після коми.
- **Питання**: Чи можна використовувати `toFixed` для точних обчислень?
  - **Відповідь**: Ні, результат — це рядок, а не число. Для обчислень потрібно конвертувати назад у число (`parseFloat`).

## Поради

- **Уникай неточностей із плаваючою комою**: Для фінансових обчислень використовуй цілі числа (наприклад, центи замість доларів) або бібліотеки, як `decimal.js`.
- **Завжди вказуй основу в `parseInt`**: Наприклад, `parseInt("08")` може бути інтерпретовано як 0 у старих браузерах, якщо не вказати `radix: 10`.
- **Використовуй `Number.isNaN` і `Number.isFinite`**: Вони точніші за глобальні `isNaN` і `isFinite`, оскільки не приводять типи.
- **Перевіряй межі чисел**: Якщо числа перевищують `Number.MAX_SAFE_INTEGER`, використовуй `BigInt`.
- **Обережно з `toFixed`**: Пам’ятай, що воно повертає рядок, а не число, і може впливати на точність.
