# Основи типів даних та структур у JavaScript

## Основні поняття

JavaScript є **динамічно типізованою** мовою, тобто змінні не прив’язані до конкретного типу даних, а їх тип визначається під час виконання. Типи даних поділяються на **примітивні** та **непримітивні (об’єкти)**.

### Примітивні типи даних

1. **Числа (Number)**: Представляють як цілі числа, так і числа з плаваючою точкою. У JavaScript є лише один числовий тип, який базується на 64-бітному форматі IEEE 754. Також є спеціальні значення: `Infinity`, `-Infinity` та `NaN` (не число).
2. **BigInt**: Використовується для роботи з цілими числами довільної довжини, які перевищують межі звичайного типу `Number`.
3. **Рядки (String)**: Послідовність символів для представлення тексту. Незмінні (immutable), тобто їх не можна змінити після створення.
4. **Булеві значення (Boolean)**: Мають два значення — `true` або `false`. Використовуються для логічних операцій.
5. **Undefined**: Значення змінної, яка була оголошена, але не ініціалізована.
6. **Null**: Представляє відсутність значення або "порожній" об’єкт.
7. **Symbol**: Унікальний і незмінний ідентифікатор, часто використовується як ключі для властивостей об’єктів.

### Непримітивні типи (Об’єкти)

- **Об’єкти (Object)**: Колекція пар ключ-значення. Використовуються для зберігання структурованих даних.
- **Масиви (Array)**: Спеціальний тип об’єкта для зберігання впорядкованих списків даних.
- **Функції (Function)**: Об’єкти, які можна викликати для виконання коду.
- Інші структури: `Map`, `Set`, `WeakMap`, `WeakSet` — спеціалізовані об’єкти для роботи з даними.

### Оператори

- **Арифметичні**: `+`, `-`, `*`, `/`, `%`, `**` (піднесення до степеня).
- **Порівняння**: `==` (нестрога рівність), `===` (строга рівність), `!=`, `!==`, `>`, `<`, `>=`, `<=`.
- **Логічні**: `&&` (і), `||` (або), `!` (не).
- **Оператор typeof**: Використовується для визначення типу значення.
- **Оператор instanceof**: Перевіряє, чи є об’єкт екземпляром певного класу чи конструктора.

## Приклади коду

### Числа та BigInt

```js
let num = 42; // Звичайне число
let float = 3.14; // Число з плаваючою точкою
let notANumber = NaN; // Не число
let infinity = Infinity;

let bigInt = 1234567890123456789012345678901234567890n; // BigInt

console.log(10 / 0); // Infinity
console.log(num + float); // 45.14
console.log(typeof bigInt); // "bigint"
```

### Рядки

```js
let greeting = "Hello, world!";
let name = "Alice";
let template = `Hello, ${name}!`; // Шаблонний рядок

console.log(greeting.length); // 13
console.log(template); // Hello, Alice!
console.log(greeting.toUpperCase()); // HELLO, WORLD!
```

### Булеві значення та логічні оператори

```js
let isAdult = true;
let hasAccess = false;

console.log(isAdult && hasAccess); // false
console.log(isAdult || hasAccess); // true
console.log(!isAdult); // false
```

### Об’єкти

```js
let person = {
  name: "John",
  age: 30,
  isStudent: false,
};

console.log(person.name); // John
person.age = 31; // Зміна значення
console.log(person); // { name: "John", age: 31, isStudent: false }
```

### Масиви

```js
let numbers = [1, 2, 3, 4, 5];
numbers.push(6); // Додавання елемента
console.log(numbers); // [1, 2, 3, 4, 5, 6]
console.log(numbers[0]); // 1
```

### Оператори порівняння

```js
console.log(5 == "5"); // true (нестрога рівність, приводить типи)
console.log(5 === "5"); // false (строга рівність, порівнює типи)
console.log(typeof 42); // "number"
console.log([] instanceof Array); // true
```

## Особливості для співбесід — Питання та відповіді

### Що таке динамічна типізація в JavaScript?

- JavaScript автоматично визначає тип змінної під час виконання. Наприклад, змінна може спочатку зберігати число, а потім рядок.
- **Питання**: Які можуть бути проблеми через динамічну типізацію?
  - **Відповідь**: Помилки через неочікуване приведення типів (наприклад, `5 + "5"` дає `"55"`) або неправильне використання значень (`null` vs `undefined`).

### У чому різниця між `==` і `===`?

- `==` виконує порівняння з приведенням типів (наприклад, `"5" == 5` → `true`).
- `===` порівнює значення і типи без приведення (`"5" === 5` → `false`).
- **Порада**: Завжди використовуй `===` для уникнення помилок через приведення типів.

### Чому `NaN` не дорівнює самому собі?

- `NaN` — це спеціальне значення, яке представляє "не число". За стандартом IEEE 754, `NaN !== NaN`.
- Перевіряти `NaN` потрібно за допомогою функції `isNaN()` або `Number.isNaN()`.
  ```js
  console.log(NaN === NaN); // false
  console.log(Number.isNaN(NaN)); // true
  ```

### Чим відрізняються `null` і `undefined`?

- `undefined` — змінна оголошена, але не ініціалізована, або значення відсутнє.
- `null` — явна вказівка на відсутність значення.
- **Питання**: Як перевірити, чи змінна має значення `null` чи `undefined`?
  - **Відповідь**: Використовуй `===` для точної перевірки. Наприклад:
    ```js
    let x;
    console.log(x === undefined); // true
    let y = null;
    console.log(y === null); // true
    ```

### Що таке об’єкти та як вони працюють у JavaScript?

- Об’єкти — це колекції властивостей, де кожна властивість має ключ (зазвичай рядок або Symbol) і значення.
- **Питання**: Чи можна змінити об’єкт, оголошений через `const`?
  - **Відповідь**: Так, можна змінювати властивості об’єкта, але не саме посилання на об’єкт.
    ```js
    const obj = { a: 1 };
    obj.a = 2; // Ок
    // obj = { b: 3 }; // Помилка
    ```

### У чому особливість масивів у JavaScript?

- Масиви є об’єктами, але з числовими індексами та спеціальними методами (`push`, `pop`, `map` тощо).
- **Питання**: Чи є масиви в JavaScript справжніми масивами?
  - **Відповідь**: Ні, це об’єкти з числовими ключами. Вони імітують поведінку масивів, але технічно є об’єктами.

## Поради

- **Використовуй `const` для об’єктів і масивів**, якщо не плануєш змінювати саме посилання. Це зменшує ризик випадкових помилок.
- **Перевіряй типи з `typeof`** перед виконанням операцій, щоб уникнути помилок через динамічну типізацію.
- **Уникай нестрогої рівності (`==`)**, оскільки вона може призводити до неочікуваних результатів через приведення типів.
- **Для великих чисел використовуй `BigInt`**, якщо точність важлива, оскільки звичайний `Number` має обмеження.
- **Ознайомся з методами масивів** (`map`, `filter`, `reduce`), оскільки вони часто використовуються на практиці та в питаннях на співбесідах.
