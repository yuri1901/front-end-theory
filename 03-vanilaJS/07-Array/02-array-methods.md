# Методи масивів у JavaScript

## Загальна інформація

- **Опис**: Цей розділ містить таблиці з усіма методами об’єкта `Array`, із зазначенням, які з них мутують масив. Включено методи з ваших коментарів і додаткові з документації MDN.
- **Особливості**:
  - Мутаційні методи змінюють вихідний масив.
  - Немутаційні методи повертають нові дані.
  - Ітераційні методи можуть впливати на масив через callback.
- **Контекст**: Маніпуляція, ітерація, аналіз масивів.

## Таблиця методів

### Ітераційні методи (не мутують масив, але callback може)

| Метод               | Опис                                                            | Мутує масив?           | Приклад використання                                  |
| ------------------- | --------------------------------------------------------------- | ---------------------- | ----------------------------------------------------- |
| **`forEach`**       | //! Викликає callback для кожного елемента.                     | Ні (але callback може) | `["a", "b"].forEach(x => console.log(x)); // a, b`    |
| **`map`**           | //! Повертає новий масив після застосування callback.           | Ні                     | `[1, 2].map(x => x * 2); // [2, 4]`                   |
| **`find`**          | //! Знаходить перший елемент, що задовольняє умову.             | Ні                     | `[1, 2, 3].find(x => x > 1); // 2`                    |
| **`findLast`**      | //! Знаходить останній елемент, що задовольняє умову.           | Ні                     | `[1, 2, 3, 2].findLast(x => x === 2); // 2`           |
| **`findIndex`**     | //! Знаходить індекс першого елемента, що задовольняє умову.    | Ні                     | `[1, 2, 3].findIndex(x => x > 1); // 1`               |
| **`findLastIndex`** | //! Знаходить індекс останнього елемента, що задовольняє умову. | Ні                     | `[1, 2, 3, 2].findLastIndex(x => x === 2); // 3`      |
| **`every`**         | //! Перевіряє, чи всі елементи задовольняють умову.             | Ні                     | `[1, 2, 3].every(x => x > 0); // true`                |
| **`reduce`**        | //! //! Зліва направо згортає масив у єдине значення.           | Ні                     | `[1, 2, 3].reduce((acc, x) => acc + x, 0); // 6`      |
| **`reduceRight`**   | //! Зправа наліво згортає масив у єдине значення.               | Ні                     | `[1, 2, 3].reduceRight((acc, x) => acc + x, 0); // 6` |
| **`filter`**        | Повертає новий масив із елементами, що задовольняють умову.     | Ні                     | `[1, 2, 3].filter(x => x > 1); // [2, 3]`             |
| **`some`**          | Перевіряє, чи хоча б один елемент задовольняє умову.            | Ні                     | `[1, 2, 3].some(x => x > 2); // true`                 |

### Мутаційні методи (змінюють вихідний масив)

| Метод                                      | Опис                                      | Мутує масив? | Приклад використання                                            |
| ------------------------------------------ | ----------------------------------------- | ------------ | --------------------------------------------------------------- |
| **`push`**                                 | //! Додає елемент у кінець масиву.        | Так          | `let arr = [1]; arr.push(2); // [1, 2]`                         |
| **`pop`**                                  | //! Видаляє останній елемент масиву.      | Так          | `let arr = [1, 2]; arr.pop(); // [1]`                           |
| **`shift`**                                | //! Видаляє перший елемент масиву.        | Так          | `let arr = [1, 2]; arr.shift(); // [2]`                         |
| **`unshift`**                              | //! Додає елемент на початок масиву.      | Так          | `let arr = [2]; arr.unshift(1); // [1, 2]`                      |
| **`splice(start, deleteCount, ...items)`** | //! Видаляє/додає елементи в масиві.      | Так          | `let arr = [1, 2, 3]; arr.splice(1, 1, 4); // [1, 4, 3]`        |
| **`sort`**                                 | //! Сортує масив на місці.                | Так          | `let arr = [3, 1, 2]; arr.sort(); // [1, 2, 3]`                 |
| **`reverse`**                              | //! Перевертає масив на місці.            | Так          | `let arr = [1, 2, 3]; arr.reverse(); // [3, 2, 1]`              |
| **`fill(value, start, end)`**              | //! Заповнює масив заданим значенням.     | Так          | `let arr = [1, 2, 3]; arr.fill(0, 1); // [1, 0, 0]`             |
| **`copyWithin(target, start, end)`**       | //! Копіює частину масиву в іншу частину. | Так          | `let arr = [1, 2, 3, 4]; arr.copyWithin(0, 2); // [3, 4, 3, 4]` |

### Немутаційні методи (не змінюють вихідний масив)

| Метод                                         | Опис                                                    | Мутує масив? | Приклад використання                               |
| --------------------------------------------- | ------------------------------------------------------- | ------------ | -------------------------------------------------- |
| **`flat(depth)`**                             | //! Вирівнює вкладені масиви до заданої глибини.        | Ні           | `[1, [2, [3]]].flat(2); // [1, 2, 3]`              |
| **`flatMap(callback)`**                       | //! Вирівнює і застосовує callback.                     | Ні           | `[1, 2].flatMap(x => [x, x * 2]); // [1, 2, 2, 4]` |
| **`concat(...arrays)`**                       | //! Об’єднує масиви в новий масив.                      | Ні           | `[1, 2].concat([3, 4]); // [1, 2, 3, 4]`           |
| **`slice(start, end)`**                       | //! Вирізає частину масиву в новий масив.               | Ні           | `[1, 2, 3].slice(1, 2); // [2]`                    |
| **`toReversed()`**                            | Повертає новий перевернутий масив.                      | Ні           | `[1, 2, 3].toReversed(); // [3, 2, 1]`             |
| **`toSorted(compareFn)`**                     | Повертає новий відсортований масив.                     | Ні           | `[3, 1, 2].toSorted(); // [1, 2, 3]`               |
| **`toSpliced(start, deleteCount, ...items)`** | Повертає новий масив із видаленими/доданими елементами. | Ні           | `[1, 2, 3].toSpliced(1, 1, 4); // [1, 4, 3]`       |
| **`with(index, value)`**                      | Повертає новий масив із заміною елемента.               | Ні           | `[1, 2, 3].with(1, 5); // [1, 5, 3]`               |

## Особливості для співбесід — Питання та відповіді

### Чим відрізняються `push` і `concat`?

- **Відповідь**: `push` мутує масив, додаючи елементи; `concat` повертає новий масив.
  ```javascript
  let arr = [1];
  arr.push(2); // [1, 2]
  let newArr = [1].concat([2]); // [1, 2], arr = [1]
  ```

### Як працює `flat()`?

- **Відповідь**: Вирівнює вкладені масиви до заданої глибини.
  ```javascript
  console.log([1, [2, [3]]].flat(1)); // [1, 2, [3]]
  console.log([1, [2, [3]]].flat(2)); // [1, 2, 3]
  ```

### Чи мутує `map` масив?

- **Відповідь**: Ні, але callback може змінити оригінал, якщо є посилання.
  ```javascript
  let arr = [{ x: 1 }];
  arr.map((item) => (item.x = 2)); // arr[0].x = 2
  ```

### Як створити глибоку копію масиву?

- **Відповідь**: Використовуйте `JSON.parse(JSON.stringify())` або рекурсію.
  ```javascript
  let arr = [1, [2]];
  let deep = JSON.parse(JSON.stringify(arr));
  deep[1][0] = 3;
  console.log(arr[1][0]); // 2
  ```

## Поради

- **Використовуйте немутаційні методи**: Для безпечної роботи з даними (`map`, `slice`).
- **Перевіряйте мутацію**: Уникайте `push`/`splice`, якщо не потрібні зміни.
- **Оптимізуйте ітерацію**: Застосовуйте `forEach` для побічних ефектів, `map` для трансформації.
- **Копіюйте розумно**: Використовуйте `slice` чи `...` для поверхневого, `JSON` — для глибокого.
- **Тестуйте вкладені масиви**: Перевіряйте поведінку при копіюванні.
