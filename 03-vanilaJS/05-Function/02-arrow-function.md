# Стрілкові функції та рекурсія у JavaScript

## Загальна інформація

- **Опис**: Стрілкові функції — сучасний синтаксис для коротких функцій. Рекурсія — метод, коли функція викликає сама себе.
- **Стрілкові функції**:
  - Синтаксис: `() => {}`, `x => x * 2`.
  - Особливості: Не мають `this`, `arguments`, `super`, не підтримують `new`.
- **Рекурсія**:
  - Базовий випадок: Умова зупинки.
  - Рекурсивний випадок: Виклик із зменшеними даними.
  - Стрілкові функції не можуть бути конструкторами.
  - Рекурсія може спричинити переповнення стеку (stack overflow).
- **Особливості**:
  - Стрілкові функції оптимізують код, але не підходять для методів об’єктів.
  - Рекурсія може викликати переповнення стеку без оптималізації.
- **Контекст**: Використовуються для коротких виразів (стрілкові) і складних алгоритмів (рекурсія).

## Приклади коду

### Стрілкові функції

```javascript
// Проста стрілкова функція
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5

// Без фігурних дужок для одного виразу
const square = (x) => x * x;
console.log(square(4)); // 16

// Проблема з `this`
const obj = {
  value: 1,
  getValue: () => this.value, // `this` = глобальний об’єкт
};
console.log(obj.getValue()); // undefined

// Правильний контекст із звичайною функцією
const obj2 = {
  value: 2,
  getValue() {
    return this.value;
  },
};
console.log(obj2.getValue()); // 2
```

### Рекурсія

```javascript
// Факторіал із рекурсією
function factorial(n) {
  if (n <= 1) return 1; // Базовий випадок
  return n * factorial(n - 1); // Рекурсивний випадок
}
console.log(factorial(5)); // 120

// Фібоначчі
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
console.log(fibonacci(6)); // 8
```

### Оптимізована рекурсія (хвіст)

```javascript
// Хвістова рекурсія для факторіалу
function factorialTail(n, acc = 1) {
  if (n <= 1) return acc;
  return factorialTail(n - 1, n * acc);
}
console.log(factorialTail(5)); // 120

// Ітеративний підхід як альтернатива
function factorialIter(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) result *= i;
  return result;
}
console.log(factorialIter(5)); // 120
```

## Особливості для співбесід — Питання та відповіді

### Чим стрілкові функції відрізняються від звичайних?

- **Відповідь**: Стрілкові не мають власного `this`, не піднімаються, не підтримують `new`.
  ```javascript
  const fn = () => this;
  console.log(fn()); // globalThis
  function fn2() {
    return this;
  }
  console.log(fn2()); // залежить від виклику
  ```

### Як уникнути переповнення стеку при рекурсії?

- **Відповідь**: Використовуйте хвостову рекурсію або ітерацію.
  ```javascript
  // Хвістова
  function tailRec(n, acc = 1) {
    if (n <= 1) return acc;
    return tailRec(n - 1, acc * n);
  }
  // Ітерація
  let result = 1;
  for (let i = 5; i > 1; i--) result *= i;
  ```

### Чи можна використовувати стрілкові функції як конструктори?

- **Відповідь**: Ні, вони не мають `prototype` і кидають помилку з `new`.
  ```javascript
  const Arrow = () => {};
  console.log(new Arrow()); // TypeError: Arrow is not a constructor
  ```

### Що таке базовий і рекурсивний випадки?

- **Відповідь**: Базовий — зупинка (наприклад, `n <= 1`), рекурсивний — виклик із меншими даними.
  ```javascript
  function countDown(n) {
    if (n <= 0) return; // Базовий
    console.log(n);
    countDown(n - 1); // Рекурсивний
  }
  countDown(3); // 3, 2, 1
  ```

### Як стрілкові функції впливають на колбеки?

- **Відповідь**: Зберігають зовнішній `this`, що корисно для колбеків.
  ```javascript
  const obj = { value: 10 };
  [1, 2].forEach(() => console.log(this.value), obj); // 10, 10
  ```

## Поради

- **Використовуй стрілкові для короткодів**: Але уникай у методах об’єктів.
- **Оптимізуй рекурсію**: Додавай хвостову рекурсію або переходь на цикли.
- **Перевіряй межі**: Уникай рекурсії з великими числами (наприклад, `factorial(10000)`).
- **Комбінуй із колбеками**: Стрілкові зручно для `map`, `filter`.
- **Тестуй `this`**: Уважно перевіряй контекст у стрілкових функціях.
- **Документуй рекурсію**: Пояснюй базовий і рекурсивний випадки.
